{
package parser

import (
"bytes"
"errors"
"fmt"
"io"
"io/ioutil"
"math"
"net"
"net/url"
"os"
"path"
"strconv"
"strings"
"unicode"
"unicode/utf8"
)
import . "github.com/philandstuff/dhall-golang/ast"

// Helper function for parsing all the operator parsing blocks
// see OrExpression for an example of how this is used
func ParseOperator(opcode int, first, rest interface{}) Expr {
    out := first.(Expr)
    if rest == nil { return out }
    for _, b := range rest.([]interface{}) {
        nextExpr := b.([]interface{})[3].(Expr)
        out = Operator{OpCode: opcode, L: out, R: nextExpr}
    }
    return out
}

}

DhallFile ← e:CompleteExpression EOF { return e, nil }

CompleteExpression ← _ e:Expression _ { return e, nil }

EOL ← "\n" / "\r\n"

BlockComment ← "{-" BlockCommentContinue

BlockCommentChunk ←
    BlockComment
  / [\t\u0020-\U0010ffff]
  / EOL

BlockCommentContinue ← "-}" / BlockCommentChunk BlockCommentContinue

NotEOL ← [\t\u0020-\U0010ffff]

LineComment ← "--" content:(NotEOL* { return string(c.text), nil}) EOL { return content, nil }

WhitespaceChunk ← ' ' / '\t' / EOL / LineComment / BlockComment

_ ← WhitespaceChunk*

_1 ← WhitespaceChunk+

Digit ← [0-9]

HexDig ← Digit / [a-f]i

SimpleLabelFirstChar ← [A-Za-z_]
SimpleLabelNextChar ← [A-Za-z0-9_/-]
SimpleLabel ← Keyword SimpleLabelNextChar+ { return string(c.text), nil }
          / !Keyword SimpleLabelFirstChar SimpleLabelNextChar*
          {
            return string(c.text), nil
          }

// QuotedLabel

Label ← label:SimpleLabel { return label, nil }

NonreservedLabel ← &(Reserved SimpleLabelNextChar) label:Label { return label, nil }
                / !Reserved label:Label { return label, nil }

AnyLabel ← Label


DoubleQuoteChunk ←
     Interpolation
   / '\\' e:DoubleQuoteEscaped { return e, nil }
   / DoubleQuoteChar

DoubleQuoteEscaped ←
       '"'
     / '$'
     / '\\'
     / '/'
     / 'b' { return []byte("\b"), nil }
     / 'f' { return []byte("\f"), nil }
     / 'n' { return []byte("\n"), nil }
     / 'r' { return []byte("\r"), nil }
     / 't' { return []byte("\t"), nil }
     / 'u' HexDig HexDig HexDig HexDig {
        i, err := strconv.ParseInt(string(c.text[1:]), 16, 32)
        return []byte(string([]rune{rune(i)})), err
     }

DoubleQuoteChar ←
     [\x20-\x21]
   / [\x23-\x5b]
   / [\x5d-\U0010ffff]

DoubleQuoteLiteral ← '"' chunks:DoubleQuoteChunk* '"' {
    var str strings.Builder
    var outChunks Chunks
    for _, chunk := range chunks.([]interface{}) {
        switch e := chunk.(type) {
        case []byte:
                str.Write(e)
        case Expr:
                outChunks = append(outChunks, Chunk{str.String(), e})
                str.Reset()
        default:
                return nil, errors.New("can't happen")
        }
    }
    return TextLit{Chunks: outChunks, Suffix: str.String()}, nil
}

SingleQuoteContinue ←
      Interpolation SingleQuoteContinue
    / EscapedQuotePair SingleQuoteContinue
    / EscapedInterpolation SingleQuoteContinue
    / SingleQuoteChar SingleQuoteContinue
    / "''"

EscapedQuotePair ← "'''" { return []byte("''"), nil }

// \u007b == '{'. This is needed because pigeon gets confused
// parsing the code block otherwise.
EscapedInterpolation ← "''${" { return []byte("$\u007b"), nil }

SingleQuoteChar ←
     [\x20-\U0010ffff]
   / '\t'
   / '\n'

SingleQuoteLiteral ← "''" EOL content:SingleQuoteContinue {
    var str strings.Builder
    var outChunks Chunks
    chunk, ok := content.([]interface{})
    for ; ok; chunk, ok = chunk[1].([]interface{}) {
        switch e := chunk[0].(type) {
        case []byte:
            str.Write(e)
        case Expr:
                outChunks = append(outChunks, Chunk{str.String(), e})
                str.Reset()
        default:
            return nil, errors.New("unimplemented")
        }
    }
    return RemoveLeadingCommonIndent(TextLit{Chunks: outChunks, Suffix: str.String()}), nil
}

Interpolation ← "${" e:CompleteExpression "}" { return e, nil }

TextLiteral ← DoubleQuoteLiteral / SingleQuoteLiteral

// reserved identifiers from semantics.md, only required for negative lookahed rules
Reserved ←
    "Natural/build" { return NaturalBuild, nil }
  / "Natural/fold" { return NaturalFold, nil }
  / "Natural/isZero" { return NaturalIsZero, nil }
  / "Natural/even" { return NaturalEven, nil }
  / "Natural/odd" { return NaturalOdd, nil }
  / "Natural/toInteger" { return NaturalToInteger, nil }
  / "Natural/show" { return NaturalShow, nil }
  / "Integer/toDouble" { return nil, errors.New("Integer/toDouble unimplemented") }
  / "Integer/show" { return nil, errors.New("Integer/show unimplemented") }
  / "Double/show" { return nil, errors.New("Double/show unimplemented") }
  / "List/build" { return ListBuild, nil }
  / "List/fold" { return ListFold, nil }
  / "List/length" { return ListLength, nil }
  / "List/head" { return ListHead, nil }
  / "List/last" { return ListLast, nil }
  / "List/indexed" { return ListIndexed, nil }
  / "List/reverse" { return ListReverse, nil }
  / "Optional/build" { return OptionalBuild, nil }
  / "Optional/fold" { return OptionalFold, nil }
  / "Text/show" { return TextShow, nil }
  / "Bool" { return Bool, nil }
  / "True" { return True, nil }
  / "False" { return False, nil }
  / "Optional" { return Optional, nil }
  / "Natural" { return Natural, nil }
  / "Integer" { return Integer, nil }
  / "Double" { return Double, nil }
  / "Text" { return Text, nil }
  / "List" { return List, nil }
  / "None" { return None, nil }
  / "Type" { return Type, nil }
  / "Kind" { return Kind, nil }
  / "Sort" { return Sort, nil }

If ← "if"
Then ← "then"
Else ← "else"
Let ← "let"
In ← "in"
As ← "as"
Using ← "using"
Merge ← "merge"
Missing ← "missing" { return Missing{}, nil }
True ← "True"
False ← "False"
Infinity ← "Infinity"
NaN ← "NaN"
Some ← "Some"

Keyword ←
    If / Then / Else
  / Let / In
  / Using / Missing / As
  / True / False
  / Infinity / NaN
  / Merge / Some

Optional ← "Optional"
Text ← "Text"
List ← "List"

Lambda ← ('\\' / 'λ')
Forall ← ("forall" / '∀')
Arrow ← ("->" / '→')

Exponent ← "e"i [+-]? Digit+

NumericDoubleLiteral ← [+-]? Digit+ ( "." Digit+ Exponent? / Exponent) {
      d, err := strconv.ParseFloat(string(c.text), 64)
      if err != nil {
         return nil, err
      }
      return DoubleLit(d), nil
}

DoubleLiteral ← d:NumericDoubleLiteral
  / Infinity { return DoubleLit(math.Inf(1)), nil }
  / "-" Infinity { return DoubleLit(math.Inf(-1)), nil }
  / NaN { return DoubleLit(math.NaN()), nil }

NaturalLiteral ← Digit+ {
      i, err := strconv.Atoi(string(c.text))
      return NaturalLit(i), err
}

IntegerLiteral ← [+-]NaturalLiteral {
      i, err := strconv.Atoi(string(c.text))
      if err != nil {
         return nil, err
      }
      return IntegerLit(i), nil
}

DeBruijn ← _ '@' _ index:NaturalLiteral { return int(index.(NaturalLit)), nil }

Variable ← name:NonreservedLabel index:DeBruijn? {
    if index != nil {
        return Var{Name:name.(string), Index:index.(int)}, nil
    } else {
        return Var{Name:name.(string)}, nil
    }
}

Identifier ← Variable / Reserved

PathCharacter ←
     '\x21'
   / [\x24-\x27]
   / [\x2a-\x2b]
   / [\x2d-\x2e]
   / [\x30-\x3b]
   / '\x3d'
   / [\x40-\x5a]
   / [\x5e-\x7a]
   / '\x7c'
   / '\x7e'

UnquotedPathComponent ← PathCharacter+ { return string(c.text), nil }

PathComponent ← '/' u:UnquotedPathComponent { return u, nil }

Path ← cs:PathComponent+ {
    // urgh, have to convert []interface{} to []string
    components := make([]string, len(cs.([]interface{})))
    for i, component := range cs.([]interface{}) {
        components[i] = component.(string)
    }
    return path.Join(components...), nil
}

Local ← ParentPath / HerePath / HomePath / AbsolutePath

ParentPath ← ".." p:Path { return Local(path.Join("..", p.(string))), nil }
HerePath ← '.' p:Path { return Local(p.(string)), nil }
HomePath ← '~' p:Path { return Local(path.Join("~", p.(string))), nil }
AbsolutePath ← p:Path { return Local(path.Join("/", p.(string))), nil }

Scheme ← "http" 's'?

HttpRaw ← Scheme "://" Authority Path ( '?' Query )? { return url.ParseRequestURI(string(c.text)) }

Authority ← (Userinfo '@')? Host (':' Port)?

Userinfo ← ( Unreserved / PctEncoded / SubDelims / ':' )*

Host ← IPLiteral / RegName

Port ← Digit*

IPLiteral ← '[' IPv6address ']'

IPv6address ← (HexDig)* ':' (HexDig / ':' / '.')* {
    addr := net.ParseIP(string(c.text))
    if addr == nil { return nil, errors.New("Malformed IPv6 address") }
    return string(c.text), nil
}

RegName ← (Unreserved / PctEncoded / SubDelims)*

PChar ← Unreserved / PctEncoded / SubDelims / [:@]

Query ← (PChar / [/?])*

PctEncoded ← '%' HexDig HexDig

Unreserved ← [A-Za-z0-9._~-]

SubDelims ← "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="

Http ← u:HttpRaw { return MakeRemote(u.(*url.URL)) }

Env ← "env:" v:(BashEnvironmentVariable / PosixEnvironmentVariable) { return v, nil }

BashEnvironmentVariable ← [A-Za-z_][A-Za-z0-9_]* {
  return EnvVar(string(c.text)), nil
}

PosixEnvironmentVariable ← '"' v:PosixEnvironmentVariableContent '"' {
  return v, nil
}

PosixEnvironmentVariableContent ← v:PosixEnvironmentVariableCharacter+ {
  var b strings.Builder
  for _, c := range v.([]interface{}) {
    _, err := b.Write(c.([]byte))
    if err != nil { return nil, err }
  }
  return EnvVar(b.String()), nil
}

PosixEnvironmentVariableCharacter ←
      `\"` { return []byte{0x22}, nil }
    / `\\` { return []byte{0x5c}, nil }
    / `\a` { return []byte{0x07}, nil }
    / `\b` { return []byte{0x08}, nil }
    / `\f` { return []byte{0x0c}, nil }
    / `\n` { return []byte{0x0a}, nil }
    / `\r` { return []byte{0x0d}, nil }
    / `\t` { return []byte{0x09}, nil }
    / `\v` { return []byte{0x0b}, nil }
    / [\x20-\x21]
    / [\x23-\x3c]
    / [\x3e-\x5b]
    / [\x5d-\x7e]

ImportType ← Missing / Local / Http / Env

ImportHashed ← i:ImportType { return ImportHashed{Fetchable: i.(Fetchable)}, nil }

Import ← i:ImportHashed _ As _1 Text { return Embed(Import{ImportHashed: i.(ImportHashed), ImportMode: RawText}), nil }
       / i:ImportHashed { return Embed(Import{ImportHashed: i.(ImportHashed), ImportMode: Code}), nil }


LetBinding ← Let _1 label:NonreservedLabel _ a:(Annotation _)?
            '=' _ v:Expression _ {
    if a != nil {
        return Binding{
            Variable: label.(string),
            Annotation: a.([]interface{})[0].(Expr),
            Value: v.(Expr),
        }, nil
    } else {
        return Binding{
            Variable: label.(string),
            Value: v.(Expr),
        }, nil
    }
}

Expression ←
      Lambda _ '(' _ label:NonreservedLabel _ ':' _1 t:Expression _ ')' _ Arrow _ body:Expression {
          return &LambdaExpr{Label:label.(string), Type:t.(Expr), Body: body.(Expr)}, nil
      }
    / If _1 cond:Expression _ Then _1 t:Expression _ Else _1 f:Expression {
          return BoolIf{cond.(Expr),t.(Expr),f.(Expr)},nil
      }
    / bindings:LetBinding+ In _1 b:Expression {
        bs := make([]Binding, len(bindings.([]interface{})))
        for i, binding := range bindings.([]interface{}) {
            bs[i] = binding.(Binding)
        }
        return MakeLet(b.(Expr), bs...), nil
      }
    / Forall _ '(' _ label:NonreservedLabel _ ':' _1 t:Expression _ ')' _ Arrow _ body:Expression {
          return &Pi{Label:label.(string), Type:t.(Expr), Body: body.(Expr)}, nil
      }
    / o:OperatorExpression _ Arrow _ e:Expression { return FnType(o.(Expr),e.(Expr)), nil }
    / Merge _1 h:ImportExpression _1 u:ImportExpression _ ':' _1 a:ApplicationExpression {
          return Merge{Handler:h.(Expr), Union:u.(Expr), Annotation:a.(Expr)}, nil
      }
    / EmptyList
    / AnnotatedExpression

Annotation ← ':' _1 a:Expression { return a, nil }

AnnotatedExpression ←
e:OperatorExpression a:(_ Annotation)? {
        if a == nil { return e, nil }
        return Annot{e.(Expr), a.([]interface{})[1].(Expr)}, nil
    }

EmptyList ← '[' _ ']' _ ':' _1 List _ a:ImportExpression {
          return EmptyList{a.(Expr)},nil
}

OperatorExpression ← ImportAltExpression

ImportAltExpression  ← OrExpression

OrExpression         ← first:PlusExpression        rest:(_ "||" _ PlusExpression)*
  {return ParseOperator(OrOp, first, rest), nil}
PlusExpression       ← first:TextAppendExpression  rest:(_ '+' _1 e:TextAppendExpression)*
  {return ParseOperator(PlusOp, first, rest), nil}
TextAppendExpression ← first:ListAppendExpression  rest:(_ "++" _ e:ListAppendExpression)*
  {return ParseOperator(TextAppendOp, first, rest), nil}
ListAppendExpression ← first:AndExpression         rest:(_ '#' _ e:AndExpression)*
  {return ParseOperator(ListAppendOp, first, rest), nil}
AndExpression        ← first:TimesExpression       rest:(_ "&&" _ e:TimesExpression)*
  {return ParseOperator(AndOp, first, rest), nil}
TimesExpression      ← first:EqualExpression       rest:(_ '*' _ e:EqualExpression)*
  {return ParseOperator(TimesOp, first, rest), nil}
EqualExpression      ← first:NotEqualExpression    rest:(_ "==" _ e:NotEqualExpression)*
  {return ParseOperator(EqOp, first, rest), nil}
NotEqualExpression   ← first:ApplicationExpression rest:(_ "!=" _ e:ApplicationExpression)*
  {return ParseOperator(NeOp, first, rest), nil}

ApplicationExpression ← f:FirstApplicationExpression rest:(_1 ImportExpression)* {
          e := f.(Expr)
          if rest == nil { return e, nil }
          for _, arg := range rest.([]interface{}) {
              e = Apply(e, arg.([]interface{})[1].(Expr))
          }
          return e,nil
      }

FirstApplicationExpression ←
       Merge _1 h:ImportExpression _1 u:ImportExpression {
             return Merge{Handler:h.(Expr), Union:u.(Expr)}, nil
          }
     / Some _1 e:ImportExpression { return Some{e.(Expr)}, nil }
     / ImportExpression

ImportExpression ← Import / SelectorExpression

SelectorExpression ← e:PrimitiveExpression ls:(_ '.' _ AnyLabel)* {
    expr := e.(Expr)
    labels := ls.([]interface{})
    for _, labelSelector := range labels {
        label := labelSelector.([]interface{})[3]
        expr = Field{expr, label.(string)}
    }
    return expr, nil
}

PrimitiveExpression ←
      DoubleLiteral
    / NaturalLiteral
    / IntegerLiteral
    / TextLiteral
    / '{' _ r:RecordTypeOrLiteral _ '}' { return r, nil }
    / '<' _ u:UnionType _ '>' { return u, nil }
    / NonEmptyListLiteral
    / Identifier
    / '(' _  e:Expression _ ')' { return e, nil }

RecordTypeOrLiteral ←
      '=' { return RecordLit(map[string]Expr{}), nil }
    / NonEmptyRecordType
    / NonEmptyRecordLiteral
    / "" { return Record(map[string]Expr{}), nil }

RecordTypeField ← name:AnyLabel _ ':' _1 expr:Expression {
    return []interface{}{name, expr}, nil
}
MoreRecordType ← _ ',' _ f:RecordTypeField {return f, nil}
NonEmptyRecordType ←
      first:RecordTypeField rest:MoreRecordType* {
          fields := rest.([]interface{})
          content := make(map[string]Expr, len(fields)+1)
          content[first.([]interface{})[0].(string)] = first.([]interface{})[1].(Expr)
          for _, field := range(fields) {
              content[field.([]interface{})[0].(string)] = field.([]interface{})[1].(Expr)
          }
          return Record(content), nil
      }

RecordLiteralField ← name:AnyLabel _ '=' _ expr:Expression {
    return []interface{}{name, expr}, nil
}
MoreRecordLiteral ← _ ',' _ f:RecordLiteralField {return f, nil}
NonEmptyRecordLiteral ←
      first:RecordLiteralField rest:MoreRecordLiteral* {
          fields := rest.([]interface{})
          content := make(map[string]Expr, len(fields)+1)
          content[first.([]interface{})[0].(string)] = first.([]interface{})[1].(Expr)
          for _, field := range(fields) {
              content[field.([]interface{})[0].(string)] = field.([]interface{})[1].(Expr)
          }
          return RecordLit(content), nil
      }

UnionType ← NonEmptyUnionType / EmptyUnionType

EmptyUnionType ← "" { return UnionType{}, nil }

NonEmptyUnionType ← first:UnionVariant rest:(_ '|' _ UnionVariant)* {
    alternatives := make(map[string]Expr)
    first2 := first.([]interface{})
    if first2[1] == nil {
        alternatives[first2[0].(string)] = nil
    } else {
        alternatives[first2[0].(string)] = first2[1].([]interface{})[3].(Expr)
    }
    if rest == nil { return UnionType(alternatives), nil }
    for _, alternativeSyntax := range rest.([]interface{}) {
        alternative := alternativeSyntax.([]interface{})[3].([]interface{})
        if alternative[1] == nil {
            alternatives[alternative[0].(string)] = nil
        } else {
            alternatives[alternative[0].(string)] = alternative[1].([]interface{})[3].(Expr)
        }
    }
    return UnionType(alternatives), nil
}

UnionVariant ← AnyLabel (_ ':' _1 Expression)?

MoreList ← ',' _ e:Expression _ {return e, nil}

NonEmptyListLiteral ←
      '[' _ first:Expression _ rest:MoreList* ']' {
          exprs := rest.([]interface{})
          content := make([]Expr, len(exprs)+1)
          content[0] = first.(Expr)
          for i, expr := range(exprs) {
              content[i+1] = expr.(Expr)
          }
          return NonEmptyList(content), nil
      }

EOF ← !.
