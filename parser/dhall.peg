{
package parser

import (
"bytes"
"errors"
"fmt"
"io"
"io/ioutil"
"math"
"os"
"strconv"
"strings"
"unicode"
"unicode/utf8"
)
import . "github.com/philandstuff/dhall-golang/ast"

}

DhallFile ← e:CompleteExpression EOF { return e, nil }

CompleteExpression ← _ e:Expression { return e, nil }

EOL ← "\n" / "\r\n"

BlockComment ← "{-" BlockCommentContinue

BlockCommentChunk ←
    BlockComment
  / [\t\u0020-\U0010ffff]
  / EOL

BlockCommentContinue ← "-}" / BlockCommentChunk BlockCommentContinue

NotEOL ← [\t\u0020-\U0010ffff]

LineComment ← "--" content:(NotEOL* { return string(c.text), nil}) EOL { return content, nil }

WhitespaceChunk ← ' ' / '\t' / EOL / LineComment / BlockComment

_ ← WhitespaceChunk*

NonemptyWhitespace ← WhitespaceChunk+

HexDig ← [0-9a-f]i

SimpleLabel ← !KeywordRaw
            [A-Za-z_] [A-Za-z0-9_/-]* { return string(c.text), nil }

// QuotedLabel

Label ← label:SimpleLabel _ { return label, nil }

NonreservedLabel ← !ReservedRaw label:Label { return label, nil }

// DoubleQuoteInterpolation ←

EscapedChar ←
  '\\'
  ( '"'
       / '$'
       / '\\'
       / '/'
       / 'b'
       / 'f'
       / 'n'
       / 'r'
       / 't'
       / 'u' HexDig HexDig HexDig HexDig
       ) {
    switch c.text[1] {
    case 'b':
        return []byte("\b"), nil
    case 'f':
        return []byte("\f"), nil
    case 'n':
        return []byte("\n"), nil
    case 'r':
        return []byte("\r"), nil
    case 't':
        return []byte("\t"), nil
    case 'u':
        i, err := strconv.ParseInt(string(c.text[2:]), 16, 32)
        return []byte(string([]rune{rune(i)})), err
    }
    return c.text[1:2], nil
}


DoubleQuoteChunk ←
     "${" e:CompleteExpression "}" { return e, nil }
   / EscapedChar
   / [\x20-\x21]
   / [\x23-\x5b]
   / [\x5d-\U0010ffff]

DoubleQuoteLiteral ← '"' chunks:DoubleQuoteChunk* '"' {
    var str strings.Builder
    var outChunks Chunks
    for _, chunk := range chunks.([]interface{}) {
        switch e := chunk.(type) {
        case []byte:
                str.Write(e)
        case Expr:
                outChunks = append(outChunks, Chunk{str.String(), e})
                str.Reset()
        default:
                return nil, errors.New("can't happen")
        }
    }
    return TextLit{Chunks: outChunks, Suffix: str.String()}, nil
}

TextLiteral ← t:DoubleQuoteLiteral _ { return t, nil }

ReservedRaw ← "Bool" { return Bool, nil }
  / "Optional" { return Optional, nil }
  / "None" { return None, nil }
  / "Natural" { return Natural, nil }
  / "Integer" { return Integer, nil }
  / "Double" { return Double, nil }
  / "Text" { return Text, nil }
  / "List" { return List, nil }
  / "True" { return True, nil }
  / "False" { return False, nil }
  / "NaN" { return DoubleLit(math.NaN()), nil }
  / "Infinity" { return DoubleLit(math.Inf(1)), nil }
  / "Type" { return Type, nil }
  / "Kind" { return Kind, nil }
  / "Sort" { return Sort, nil }

Reserved ← r:ReservedRaw _ { return r, nil }

KeywordRaw ← "if"
  / "then"
  / "else"
  / "let"
  / "in"
  / "as"
  / "using"
  / "merge"
  / "constructors"
  / "Some"

If ← "if" NonemptyWhitespace
Then ← "then" NonemptyWhitespace
Else ← "else" NonemptyWhitespace
Let ← "let" NonemptyWhitespace
In ← "in" NonemptyWhitespace
As ← "as" NonemptyWhitespace
Using ← "using" NonemptyWhitespace
Merge ← "merge" NonemptyWhitespace
Some ← "Some" NonemptyWhitespace
Optional ← "Optional" _
Text ← "Text" _
List ← "List" _

Equal ← '=' _
Plus ← '+' NonemptyWhitespace
Times ← '*' _
Dot ← '.' _
OpenBrace ← '{' _
CloseBrace ← '}' _
OpenBracket ← '[' _
CloseBracket ← ']' _
Comma ← ',' _
OpenParens ← '(' _
CloseParens ← ')' _
At ← '@' _
Colon ← ':' NonemptyWhitespace

Lambda ← ('\\' / 'λ') _
Forall ← ("forall" / '∀') _
Arrow ← ("->" / '→') _

Exponent ← "e"i [+-]? [0-9]+

DoubleLiteralRaw ← [+-]? [0-9]+ ( "." [0-9]+ Exponent? / Exponent) {
      d, err := strconv.ParseFloat(string(c.text), 64)
      if err != nil {
         return nil, err
      }
      return DoubleLit(d), nil
}

DoubleLiteral ← d:DoubleLiteralRaw _ { return d, nil }

NaturalLiteralRaw ← [0-9]+ {
      i, err := strconv.Atoi(string(c.text))
      return NaturalLit(i), err
}

NaturalLiteral ← n:NaturalLiteralRaw _ { return n, nil }

IntegerLiteralRaw ← [+-][0-9]+ {
      i, err := strconv.Atoi(string(c.text))
      if err != nil {
         return nil, err
      }
      return IntegerLit(i), nil
}

IntegerLiteral ← i: IntegerLiteralRaw _ { return i, nil }

DeBruijn ← At index:NaturalLiteral { return int(index.(NaturalLit)), nil }

Identifier ← name:Label index:DeBruijn? {
    if index != nil {
        return Var{Name:name.(string), Index:index.(int)}, nil
    } else {
        return Var{Name:name.(string)}, nil
    }
}

IdentifierReservedPrefix ←
         name:(ReservedRaw [A-Za-z0-9/_-]+ { return string(c.text),nil }) _
         index:DeBruijn? {
    if index != nil {
        return Var{Name:name.(string), Index:index.(int)}, nil
    } else {
        return Var{Name:name.(string)}, nil
    }
}

Env ← "env:" v:(BashEnvironmentVariable / PosixEnvironmentVariable) _ { return v, nil }

BashEnvironmentVariable ← [A-Za-z_][A-Za-z0-9_]* {
  return ImportType{EnvVar: string(c.text)}, nil
}

PosixEnvironmentVariable ← '"' v:PosixEnvironmentVariableContent '"' {
  return v, nil
}

PosixEnvironmentVariableContent ← v:PosixEnvironmentVariableCharacter+ {
  var b strings.Builder
  for _, c := range v.([]interface{}) {
    _, err := b.Write(c.([]byte))
    if err != nil { return nil, err }
  }
  return ImportType{EnvVar: b.String()}, nil
}

PosixEnvironmentVariableCharacter ←
      `\"` { return []byte{0x22}, nil }
    / `\\` { return []byte{0x5c}, nil }
    / `\a` { return []byte{0x07}, nil }
    / `\b` { return []byte{0x08}, nil }
    / `\f` { return []byte{0x0c}, nil }
    / `\n` { return []byte{0x0a}, nil }
    / `\r` { return []byte{0x0d}, nil }
    / `\t` { return []byte{0x09}, nil }
    / `\v` { return []byte{0x0b}, nil }
    / [\x20-\x21]
    / [\x23-\x3c]
    / [\x3e-\x5b]
    / [\x5d-\x7e]

ImportType ← Env

ImportHashed ← i:ImportType { return ImportHashed{ImportType: i.(ImportType)}, nil }

Import ← i:ImportHashed As Text { return Embed(Import{ImportHashed: i.(ImportHashed), ImportMode: RawText}), nil }
       / i:ImportHashed { return Embed(Import{ImportHashed: i.(ImportHashed), ImportMode: Code}), nil }

// NOTE: Every rule past this point should only reference rules that end with
// whitespace.  This ensures consistent handling of whitespace in the absence of
// a separate lexing step

LetBinding ← Let label:NonreservedLabel a:Annotation? Equal v:Expression {
    if a != nil {
        return Binding{
            Variable: label.(string),
            Annotation: a.(Expr),
            Value: v.(Expr),
        }, nil
    } else {
        return Binding{
            Variable: label.(string),
            Value: v.(Expr),
        }, nil
    }
}

Expression ←
      Lambda OpenParens label:NonreservedLabel Colon t:Expression CloseParens Arrow body:Expression {
          return &LambdaExpr{Label:label.(string), Type:t.(Expr), Body: body.(Expr)}, nil
      }
    / If cond:Expression Then t:Expression Else f:Expression {
          return BoolIf{cond.(Expr),t.(Expr),f.(Expr)},nil
      }
    / bindings:LetBinding* In b:Expression {
        bs := make([]Binding, len(bindings.([]interface{})))
        for i, binding := range bindings.([]interface{}) {
            bs[i] = binding.(Binding)
        }
        return MakeLet(b.(Expr), bs...), nil
      }
    / Forall OpenParens label:NonreservedLabel Colon t:Expression CloseParens Arrow body:Expression {
          return &Pi{Label:label.(string), Type:t.(Expr), Body: body.(Expr)}, nil
      }
    / o:OperatorExpression Arrow e:Expression { return &Pi{"_",o.(Expr),e.(Expr)}, nil }
    / AnnotatedExpression

Annotation ← Colon a:Expression { return a, nil }

AnnotatedExpression ←
    EmptyList
  / e:OperatorExpression a:Annotation? {
        if a == nil { return e, nil }
        return Annot{e.(Expr), a.(Expr)}, nil
    }

EmptyList ← OpenBracket CloseBracket Colon List a:ImportExpression {
          return EmptyList{a.(Expr)},nil
}

OperatorExpression ← ImportAltExpression

ImportAltExpression ← PlusExpression

MorePlus ← Plus e:TimesExpression { return e, nil }
PlusExpression ←
      first:TimesExpression rest:MorePlus* {
          a := first.(Expr)
          if rest == nil { return a, nil }
          for _, b := range rest.([]interface{}) {
              a = NaturalPlus{L: a, R: b.(Expr)}
          }
          return a, nil
      }

MoreTimes ← Times e:ApplicationExpression { return e, nil }
TimesExpression ←
      first:ApplicationExpression rest:MoreTimes* {
          a := first.(Expr)
          if rest == nil { return a, nil }
          for _, b := range rest.([]interface{}) {
              a = NaturalTimes{L: a, R: b.(Expr)}
          }
          return a, nil
      }

ApplicationExpression ← s:Some? f:ImportExpression rest:ImportExpression* {
          e := f.(Expr)
          if rest == nil { return e, nil }
          for _, arg := range rest.([]interface{}) {
              e = &App{Fn:e, Arg: arg.(Expr)}
          }
          if s != nil {
             return Some{e}, nil
          }
          return e,nil
      }

ImportExpression ← Import / SelectorExpression

SelectorExpression ← e:PrimitiveExpression ls:(Dot Label)* {
    expr := e.(Expr)
    labels := ls.([]interface{})
    for _, labelSelector := range labels {
        label := labelSelector.([]interface{})[1]
        expr = Field{expr, label.(string)}
    }
    return expr, nil
}

PrimitiveExpression ←
      DoubleLiteral
    / NaturalLiteral
    / IntegerLiteral
    / "-Infinity" { return DoubleLit(math.Inf(-1)), nil }
    / TextLiteral
    / OpenBrace r:RecordTypeOrLiteral CloseBrace { return r, nil }
    / NonEmptyListLiteral
    / IdentifierReservedPrefix
    / Reserved
    / Identifier
    / OpenParens e:Expression CloseParens { return e, nil }

RecordTypeOrLiteral ←
      Equal { return RecordLit(map[string]Expr{}), nil }
    / NonEmptyRecordType
    / NonEmptyRecordLiteral
    / "" { return Record(map[string]Expr{}), nil }

RecordTypeField ← name:Label Colon expr:Expression {
    return []interface{}{name, expr}, nil
}
MoreRecordType ← Comma f:RecordTypeField {return f, nil}
NonEmptyRecordType ←
      first:RecordTypeField rest:MoreRecordType* {
          fields := rest.([]interface{})
          content := make(map[string]Expr, len(fields)+1)
          content[first.([]interface{})[0].(string)] = first.([]interface{})[1].(Expr)
          for _, field := range(fields) {
              content[field.([]interface{})[0].(string)] = field.([]interface{})[1].(Expr)
          }
          return Record(content), nil
      }

RecordLiteralField ← name:Label Equal expr:Expression {
    return []interface{}{name, expr}, nil
}
MoreRecordLiteral ← Comma f:RecordLiteralField {return f, nil}
NonEmptyRecordLiteral ←
      first:RecordLiteralField rest:MoreRecordLiteral* {
          fields := rest.([]interface{})
          content := make(map[string]Expr, len(fields)+1)
          content[first.([]interface{})[0].(string)] = first.([]interface{})[1].(Expr)
          for _, field := range(fields) {
              content[field.([]interface{})[0].(string)] = field.([]interface{})[1].(Expr)
          }
          return RecordLit(content), nil
      }

MoreList ← Comma e:Expression {return e, nil}

NonEmptyListLiteral ←
      OpenBracket first:Expression rest:MoreList* CloseBracket {
          exprs := rest.([]interface{})
          content := make([]Expr, len(exprs)+1)
          content[0] = first.(Expr)
          for i, expr := range(exprs) {
              content[i+1] = expr.(Expr)
          }
          return NonEmptyList(content), nil
      }

EOF ← !.
